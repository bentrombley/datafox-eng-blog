<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DataFox Tech Blog</title>
    <description>DataFox Tech Blog</description>
    <link>http://datafox.co/</link>
    <atom:link href="http://datafox.co/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>10 Great JavaScript Utils You Should Stop Reinventing</title>
        <description>&lt;p&gt;I’ve wasted more time than I care to admit reinventing these wheels. These utilities are all small and well documented.  Just use them.&lt;/p&gt;

&lt;h2 id=&quot;numeraljshttpnumeraljscom&quot;&gt;1.  &lt;a href=&quot;http://numeraljs.com/&quot;&gt;NumeralJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Ever written code to format 31235892 as “31,235,892” or “$31.2m”?  This is a simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var numeral = require(&#39;numeral&#39;);
numeral(31235892).format(&#39;$0.0a&#39;);  // $31.2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://numeraljs.com/&quot;&gt;NumeralJS&lt;/a&gt; has support for localization and can parse strings like “32m” back into numbers.&lt;/p&gt;

&lt;h2 id=&quot;momentjshttpmomentjscom&quot;&gt;2.  &lt;a href=&quot;http://momentjs.com/&quot;&gt;MomentJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Formatting and manipulating dates creates confusing and bug-ridden code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var yesterday = new Date();
yesterday.setDate(yesterday.getDate() - 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://momentjs.com/&quot;&gt;MomentJS&lt;/a&gt; makes this all ridiculously easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var yesterday = moment().subtract(1, &#39;days&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or better still:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var trialMessage = &quot;Your trial expires in &quot; + moment(expirationDate).fromNow();
// &quot;Your trial expires in 14 days&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MomentJS also has support for localization so you can delight your international customers like a pro.&lt;/p&gt;

&lt;h2 id=&quot;underscorejshttpunderscorejsorg&quot;&gt;3. &lt;a href=&quot;http://underscorejs.org/&quot;&gt;UnderscoreJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Underscore is a great way to avoid boilerplate code when manipulating arrays and objects.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// remove duplicate values
values = _.uniq(values);

// sort by all the user objects by the &#39;name&#39; field
users = _.sortBy(users, &#39;name&#39;);

// remove null/empty values from the list
names = _.compact(names);

// get all of the values from an object
var values = _.values(myObject);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing complicated, just the sort of code you shouldn’t bother reinventing.&lt;/p&gt;

&lt;h2 id=&quot;asynchttpsgithubcomcaolanasync&quot;&gt;4. &lt;a href=&quot;https://github.com/caolan/async&quot;&gt;async&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Async simplifies many common node practices like calling functions in parallel or series and handling their errors.  For example we can simplify this indentation pyramid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User.findOne({name: &#39;Helen&#39;}, function(err, user) {
  if (err) {
    callback(err);
  } else {
    Account.findOne({user_id: user._id}, function(err, account) {
    if (err) {
      callback(err);
    } else {
      makeAnApiCall(account, function(err, response) {
        if (err) {
          callback(err);
        } else {
          callback(null, response);
        }
      }
    }
    })
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to a simple list &lt;code&gt;async.waterfall&lt;/code&gt; call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async.waterfall([
  function(next) {
     User.findOne({name: &#39;Helen&#39;}, next);
  },

  function(user, next) {
    Account.findOne({user_id: user._id}, next);
  },

  function(account, next) {
    makeAnApiCall(account, next);
  }
], callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;commanderhttpsgithubcomvisionmediacommanderjs&quot;&gt;5. &lt;a href=&quot;https://github.com/visionmedia/commander.js&quot;&gt;Commander&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Add proper command-line arguments to your scripts in Node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Commander = require(&#39;commander&#39;);
Commander
  .option(&#39;--user-id &amp;lt;id&amp;gt;&#39;, &#39;user id to retrieve&#39;)
  .parse(process.argv);

userId = Commander.userId;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/visionmedia/commander.js&quot;&gt;Commander&lt;/a&gt; automatically fills in the –help:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ coffee my_script.coffee --help

Usage: my_script.coffee [options]

Options:

  -h, --help         output usage information
  --user-id &amp;lt;id&amp;gt;     user id to retrieve
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;requesthttpsgithubcommikealrequest&quot;&gt;6.  &lt;a href=&quot;https://github.com/mikeal/request&quot;&gt;Request&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mikeal/request&quot;&gt;Request&lt;/a&gt; is more than a nice-to-have, it’s practically a requirement for making HTTP requests in Node.  The library lets you make simple GET requests easily:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = require(&#39;request&#39;);
request(&#39;http://www.google.com&#39;, function (error, response, body) {
  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it supports advanced options like multi-part POSTs, streaming, and more.&lt;/p&gt;

&lt;h2 id=&quot;helmethttpsgithubcomevilpackethelmet&quot;&gt;7.  &lt;a href=&quot;https://github.com/evilpacket/helmet&quot;&gt;Helmet&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/evilpacket/helmet&quot;&gt;Helmet&lt;/a&gt; adds security best practices to your Express app painlessly, without requiring you to muck with headers and the various browser compatibility.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var helmet = require(&#39;helmet&#39;);
app = express();

// use default security settings
app.use(helmet());

// or enable one at a time
app.use(helmet.hsts());  // HTTP Strict Transport Security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To quickly check your site’s security headers and settings, try the free &lt;a href=&quot;https://chrome.google.com/webstore/detail/recx-security-analyser/ljafjhbjenhgcgnikniijchkngljgjda&quot;&gt;ExtensionRecx Security Analyser Chrome Extension&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stream-workerhttpsgithubcomgoodeggsstream-worker&quot;&gt;8. &lt;a href=&quot;https://github.com/goodeggs/stream-worker&quot;&gt;Stream Worker&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/goodeggs/stream-worker&quot;&gt;Stream Worker&lt;/a&gt; simplifies the routine task of processing a Node stream.  For example, iterating over a large results from MongoDB:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// stream over all users
var stream = Users.find().stream();
var CONCURRENCY = 5;
var processUser = function (user, callback) { ... };
StreamWorker(stream, CONCURRENCY, processUser, callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StreamWorker handles the &lt;code&gt;pause()&lt;/code&gt; and &lt;code&gt;resume()&lt;/code&gt; in the stream as well as handling any errors, including thrown Exceptions.&lt;/p&gt;

&lt;h2 id=&quot;colorshttpsgithubcommarakcolorsjs&quot;&gt;9.  &lt;a href=&quot;https://github.com/Marak/colors.js&quot;&gt;Colors&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/nyan-cat-console.png&quot; style=&quot;width: 100%&quot; /&gt;
&lt;small&gt;Running tests is always fun with nyan cat!&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Okay, you may not &lt;em&gt;need&lt;/em&gt; to add colors to your console output, but it’s definitely fun.  &lt;a href=&quot;https://github.com/Marak/colors.js&quot;&gt;Colors&lt;/a&gt; saves you the hassle of dealing with ANSI color codes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colors = require(&#39;colors&#39;);
console.error(&quot;make this text red&quot;.red);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shouldjshttpsgithubcomshouldjsshouldjs&quot;&gt;10.  &lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;ShouldJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ShouldJS helps you add clear assert statements to your unit tests while eliminiating lots of boilerplate.  Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;functionToTest(function(err, user) {

  // easy static asserts
  should.not.exist(err);
  should.exist(user);

  // and easy object-oriented checks
  user.should.have.property(&#39;name&#39;, &#39;Expected Name&#39;);

  // assertions can easily be chained in a nice readable format
  user.age.should.be.greaterThan(18).and.lessThan(25);

  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;ShouldJS&lt;/a&gt; plugs smoothly into test frameworks like &lt;a href=&quot;http://visionmedia.github.io/mocha/&quot;&gt;mocha&lt;/a&gt; and you can choose whether to write simple asserts or fully English-like semantic assertions.&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Sep 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/09/01/10-great-js-utils-you-should-stop-reinventing/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/09/01/10-great-js-utils-you-should-stop-reinventing/</guid>
      </item>
    
      <item>
        <title>Edit CoffeeScript like a Pro in 6 Minutes</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/sublime-lint-errors.png&quot; style=&quot;width: 100%&quot; /&gt;
&lt;small&gt;&lt;b&gt;Pictured Above:&lt;/b&gt; See errors and inconsistencies in your code as you type.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;There are tons of articles explaining how great CoffeeScript is as a language (which is true), but few that actually talk about how you should set up your dev environment to write it.  As a CoffeeScript shop, this is how we do it at DataFox.&lt;/p&gt;

&lt;h2 id=&quot;sublime-text-editor&quot;&gt;Sublime Text Editor&lt;/h2&gt;

&lt;p&gt;To start, I tried to use my favorite tools, &lt;a href=&quot;http://www.vim.org/&quot;&gt;vim&lt;/a&gt; and &lt;a href=&quot;http://www.jetbrains.com/idea/&quot;&gt;IntelliJ&lt;/a&gt;.  However, while IntelliJ is great at Python, Java, Scala, and PHP, its CoffeeScript plugin is woefully lacking.  Vim, meanwhile, takes extensive configuration to support advanced features like linting, and can be a polarizing choice when hiring engineers used to IDE or emacs.&lt;/p&gt;

&lt;p&gt;Fortunately, &lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime&lt;/a&gt; is a fanastic text editor with much of the power of an IDE without the bloat.  Plus, it comes with a solid Vim plugin that approaches the full functionality of the real thing.&lt;/p&gt;

&lt;h2 id=&quot;set-up-sublime-for-coffeescript-6-min&quot;&gt;Set up Sublime for CoffeeScript (6 min)&lt;/h2&gt;

&lt;h3 id=&quot;install-sublime-text-3httpwwwsublimetextcom3-60s&quot;&gt;Install &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;Sublime Text 3&lt;/a&gt; (60s)&lt;/h3&gt;
&lt;p&gt;Don’t install Sublime Text 2 or the plugins won’t work.&lt;/p&gt;

&lt;h3 id=&quot;install-package-controlhttpssublimewbondnetinstallation-30s&quot;&gt;Install &lt;a href=&quot;https://sublime.wbond.net/installation&quot;&gt;Package Control&lt;/a&gt; (30s)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://sublime.wbond.net/installation&quot;&gt;Package Control&lt;/a&gt; makes installing plugins virtually instantaneous.  Follow the instructions on the page.&lt;/p&gt;

&lt;h3 id=&quot;install-plugins-120s&quot;&gt;Install Plugins (120s)&lt;/h3&gt;
&lt;p&gt;Access the “Package Control: Install Package” command by opening the &lt;a href=&quot;http://docs.sublimetext.info/en/sublime-text-3/extensibility/command_palette.html&quot;&gt;command pallette&lt;/a&gt; (&lt;code&gt;shift-cmd-p&lt;/code&gt; on Mac, &lt;code&gt;shift-ctrl-p&lt;/code&gt; on Windows) and typing “install”.&lt;/p&gt;

&lt;p&gt;Then use the autocomplete to quickly install thse plugins:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git&lt;/li&gt;
  &lt;li&gt;git gutter&lt;/li&gt;
  &lt;li&gt;Better CoffeeScript&lt;/li&gt;
  &lt;li&gt;sidebar enhancements&lt;/li&gt;
  &lt;li&gt;SublimeLinter&lt;/li&gt;
  &lt;li&gt;SublimeLinter-coffeelint&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And include these plugins if you use any of these languages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LESS&lt;/li&gt;
  &lt;li&gt;Handlebars&lt;/li&gt;
  &lt;li&gt;Jade&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sublime is awesome and will install the plugins without any restart.&lt;/p&gt;

&lt;h3 id=&quot;update-your-settings-30s&quot;&gt;Update Your Settings (30s)&lt;/h3&gt;

&lt;p&gt;CoffeeScript relies on consistent indentation, so update your settings to enforce it (&lt;em&gt;and make sure your team does the same!&lt;/em&gt;).  Indentation is an oddly personal matter, so modify as needed.  Edit the settings (&lt;code&gt;cmd+,&lt;/code&gt;) and paste in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;auto_indent&quot;: true,
  &quot;color_scheme&quot;: &quot;Packages/User/Monokai (SL).tmTheme&quot;,
  &quot;detect_indentation&quot;: false,
  &quot;file_exclude_patterns&quot;:
  [
  ],
  &quot;ignored_packages&quot;:
  [
  ],
  &quot;smart_indent&quot;: false,
  &quot;tab_size&quot;: 2,
  &quot;translate_tabs_to_spaces&quot;: true,
  &quot;trim_trailing_white_space_on_save&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important thing is to standardize your spacing/tabbing and disable the automatic indentation which can cause bugs.&lt;/p&gt;

&lt;h3 id=&quot;setup-linting-120s&quot;&gt;Setup Linting (120s)&lt;/h3&gt;

&lt;p&gt;CoffeeScript is a very “expressive” untyped language which really means it is very ambiguous language with lots of easy-to-make mistakes. Linting takes one minute to setup. Seriously, just do it.&lt;/p&gt;

&lt;h4 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h4&gt;
&lt;p&gt;I assume you have Node and npm installed already.&lt;/p&gt;

&lt;h4 id=&quot;install-coffeelint&quot;&gt;Install Coffeelint&lt;/h4&gt;
&lt;p&gt;Note it must be installed globally for Sublime to call it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  npm install -g coffeelint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test that it works by running it on a file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  coffeelint path/to/a/file.coffee
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;optional-configure-lint-rules&quot;&gt;(Optional) Configure Lint Rules&lt;/h4&gt;

&lt;p&gt;Createa &lt;code&gt;coffeelint.json&lt;/code&gt; file in your project by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cd &amp;lt;project root&amp;gt;
  coffeelint --makeconfig &amp;gt; coffeelint.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the file to turn on/off the rules, which are all &lt;a href=&quot;http://www.coffeelint.org/#options&quot;&gt;clearly documented&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;optional-fix-nvm--zsh&quot;&gt;(Optional) Fix nvm + zsh&lt;/h4&gt;
&lt;p&gt;You may need to also do these steps, taken from the &lt;a href=&quot;https://github.com/SublimeLinter/SublimeLinter-coffeelint&quot;&gt;coffeelint documentation&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If you are using &lt;code&gt;nvm&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt;, ensure that the line to load nvm is in &lt;code&gt;.zshenv&lt;/code&gt; and not &lt;code&gt;.zshrc&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In order for &lt;code&gt;coffeelint&lt;/code&gt; to be executed by SublimeLinter, you must ensure that its path is available to SublimeLinter. Before going any further, please read and follow the steps in &lt;a href=&quot;http://sublimelinter.readthedocs.org/en/latest/troubleshooting.html#finding-a-linter-executable&quot;&gt;“Finding a linter executable”&lt;/a&gt; through “Validating your PATH” in the documentation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On Mac, this means you should open terminal and type &lt;code&gt;which coffeelint&lt;/code&gt; which will give you a path like &lt;strong&gt;/usr/local/bin/&lt;/strong&gt;coffeelint.  Then type &lt;code&gt;echo $PATH&lt;/code&gt; and if you don’t see &lt;strong&gt;/usr/local/bin&lt;/strong&gt; (or whatever you see) add it by editing &lt;code&gt;~/.bashrc&lt;/code&gt; or &lt;code&gt;~/.zshrc&lt;/code&gt; with the line &lt;code&gt;export PATH=$PATH:/usr/local/bin&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;optional-enforce-linting-as-a-git-hook&quot;&gt;(Optional) Enforce Linting as a Git Hook&lt;/h4&gt;

&lt;p&gt;To enforce your new linting rules, create a pre-commit git hook by editing &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exitCode=0
for file in `git diff --cached --name-only | grep &quot;\.coffee$&quot;`; do
  # ignore files that were deleted/moved as part of the commit
  if [ -e ${file} ]
  then
    coffeelint ${file}
    exitCode=$((${exitCode} + $?))
  fi
done

if [[ exitCode -ne 0 ]];
then
  echo &quot;Coffee linting has failed, please fix the error(s).  If this is an incorrect error, either fix our linting rules (in coffeelint.json) or in this case commit with the --no-verify flag.&quot; 1&amp;gt;&amp;amp;2;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will run the linter on all edited files when you commit.  I don’t believe in tying developers’ hands, so you can always skip this rule by running &lt;code&gt;git commit --no-verify&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is also a good idea to symlink &lt;code&gt;.git/hooks&lt;/code&gt; to a directory in your repo so you can easily share hooks across your team.&lt;/p&gt;

&lt;h4 id=&quot;restart-sublime&quot;&gt;Restart Sublime&lt;/h4&gt;

&lt;h4 id=&quot;customize-sublimelinter&quot;&gt;Customize SublimeLinter&lt;/h4&gt;

&lt;p&gt;Edit the SublimeLinter rules, by opening the context menu (right-click) and modifying:
    - Lint Mode &amp;gt; Background
    - Mark Style &amp;gt; No Column Highlights Line
    - Mark Style &amp;gt; Stippled Underline&lt;/p&gt;

&lt;p&gt;This will lint your files as you work and show errors with red underlines (of course, you can change this).&lt;/p&gt;

&lt;h4 id=&quot;test-it-out&quot;&gt;Test It Out&lt;/h4&gt;
&lt;p&gt;Open a .coffee file and behold!&lt;/p&gt;

&lt;p&gt;It took a lot of trial-and-error to arrive at this setup, so I hope it is helpful.  If you have any other tips or feedback please share them with us: ops [at] datafox.co.&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/coffeescript/2014/08/23/sublime-for-coffeescript/</link>
        <guid isPermaLink="true">http://datafox.co/coffeescript/2014/08/23/sublime-for-coffeescript/</guid>
      </item>
    
      <item>
        <title>Automate Everything Using Hipchat</title>
        <description>&lt;p&gt;We’re huge fans of &lt;a href=&quot;https://www.hipchat.com/&quot;&gt;HipChat&lt;/a&gt; here at DataFox and it has rapidly become our central means of communication.&lt;/p&gt;

&lt;p&gt;We started by using it as a simple instant messenger for 1:1 conversations, and then expanded to using the chat rooms as a way to send out customer feedback without clogging our inboxes.  And it has become the way to broadcast announcements like: &lt;strong&gt;@all&lt;/strong&gt; order lunch from &lt;a href=&quot;http://doordash.com&quot;&gt;doordash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But that’s just the beginning.  HipChat is also &lt;em&gt;the&lt;/em&gt; simplest way to communicate with our automated tools and processes.  No more e-mails or dashboards spread across 10 different systems.  By consolidating our messaging through HipChat we get all of our alerts in one place and can instantly discuss everything that is happening.&lt;/p&gt;

&lt;h3 id=&quot;deployment-and-configuration&quot;&gt;Deployment and Configuration&lt;/h3&gt;

&lt;h4 id=&quot;continuous-integration&quot;&gt;Continuous Integration&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;Jenkins&lt;/a&gt; has become the standard way to run continuous integration and deployment, and it defaults to e-mailing you when builds or tests fail.  But if you’re like me, you’ve already set up e-mail filters to ignore this noise.&lt;/p&gt;

&lt;p&gt;Fortunately, it takes less than 5 minutes to install and configure the &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/HipChat+Plugin&quot;&gt;HipChat plugin&lt;/a&gt; to broadcast when builds fail.  Now everyone sees a growl notification on failure (configurable, of course) and you can discuss the issue right there with your team.  No more e-mail threads!&lt;/p&gt;

&lt;h4 id=&quot;deployment&quot;&gt;Deployment&lt;/h4&gt;
&lt;p&gt;We use &lt;a href=&quot;http://docs.ansible.com/index.html&quot;&gt;Ansible&lt;/a&gt; for all of our deployment and configuration, and highly recommend it.  Ansible is designed to simple and powerful, with almost no setup.  For example, Ansible comes with a hipchat module that makes it trivial to broadcast when you’ve deployed code to a server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
# ... steps to deploy your code ...

- name: &quot;Broadcast deployment in hipchat&quot;
  hipchat: &amp;gt;
    token={{ hipchat_api_key }}
    room={{ hipchat_engineering_room_id }}
    msg=&quot;{{ inventory_hostname }} server deployed.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in your &lt;code&gt;vars.yml&lt;/code&gt; file you define these two variables (inventory_hostname is the server name, like “db.datafox.co”)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
hipchat_api_key: ...
hipchat_engineering_room_id: ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows up as an alert like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hipchat-screenshot.png&quot; style=&quot;width: 100%&quot; /&gt;
&lt;small&gt;&lt;b&gt;Pictured Above:&lt;/b&gt; HipChat showing a git push to our Master branch, followed by an automated Jenkins build and Ansible deployment. Unfortunately, this deployment resulted in a bug which was subsequently caught by bugsnag and displayed prominently in HipChat.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Similarly, it’s trivial to broadcast changes in configuration.  Have you ever wasted 4 hours debugging an issue only to learn that someone has had just updated a conf file?  With a few lines in ansible you can create a log of all changes to your production servers.&lt;/p&gt;

&lt;h3 id=&quot;monitoring&quot;&gt;Monitoring&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://mmonit.com/monit/&quot;&gt;Monit&lt;/a&gt; is a very lightweight and powerful tool for monitoring your servers and services.  For example, we can alert if a server is running out of storage, by creating a file at &lt;code&gt;/etc/monit/conf.d/diskspace&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check filesystem rootfs with path /
if space usage &amp;gt; 80% then alert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s also easy to monitor our various backend services and remote connections.  By default monit will send alert e-mails, but it’s far more useful to have the messages sent to hipchat where they can trigger a growl notification and show up in context of any recent deployments or other changes.&lt;/p&gt;

&lt;p&gt;To make this work we just wrote a quick-and-dirty python script to send hipchat messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys, urllib, urllib2, json

values = {
  &#39;room_id&#39;        : 12345,
  &#39;message&#39;        : &#39;message to send&#39;,
  &#39;color&#39;          : &#39;red&#39;,
  &#39;from&#39;           : &#39;server.datafox.co&#39;,
  &#39;notify&#39;         : 0,
  &#39;message_format&#39; : &#39;text&#39;
}

# quick-and-dirty parsing of command line argumentsj
last_command = &#39;&#39;
for i, arg in enumerate(sys.argv):
  if i % 2 == 1:
    last_command = arg
  elif i != 0:
    if last_command == &#39;-m&#39;:
      values[&#39;message&#39;] = arg
    elif last_command == &#39;-f&#39;:
      values[&#39;from&#39;] = arg
    elif last_command == &#39;-r&#39;:
      room_id = arg
    elif last_command == &#39;-c&#39;:
      values[&#39;color&#39;] = arg
    elif last_command == &#39;-n&#39;:
      values[&#39;notify&#39;] = arg
    elif last_command == &#39;-fm&#39;:
      values[&#39;format&#39;] = arg
    else:
      print &#39;Unrecognized argument: &#39; + last_command
      sys.exit()

url = &#39;https://api.hipchat.com/v1/rooms/message?auth_token= ...&#39;
req = urllib2.Request(url, urllib.urlencode(values))
urllib2.urlopen(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then invoke it from monit like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# if service is unavailable 3 times in a row, send an alert that we are restarting
if failed host localhost port 12345 protocol http for 3 cycles then restart
then exec &quot;/var/hipchat/hipchat_cli.py
  -m &#39;some-server process failed on server.datafox.co -- restarting.&#39;
  -f &#39;Monit&#39; -n 1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bugs-and-uncaught-exceptions&quot;&gt;Bugs and Uncaught Exceptions&lt;/h3&gt;

&lt;p&gt;We use &lt;a href=&quot;https://bugsnag.com&quot;&gt;Bugsnag&lt;/a&gt; to report uncaught errors in our frontend JavaScript, as well as in our backend NodeJS and Python services.  I haven’t used any of the competing products, but Bugsnag was extremely easy to setup and automatically groups all errors,  so we are alerted the 1st, 10th, 100th, etc. time an error occurs.&lt;/p&gt;

&lt;p&gt;Connecting Bugsnag to HipChat takes less than 60 seconds, and now we can immediately see if the errors started occurring after a deployment.&lt;/p&gt;

&lt;h3 id=&quot;and-more&quot;&gt;And More…&lt;/h3&gt;

&lt;p&gt;With widespread adoption it seems like most cloud-based services support HipChat.  We particularly rely on NewRelic alerts, but also use Github.  The only concern is drowning out the useful signal with noise (e.g. github commits merged to master).&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/hipchat/2014/08/09/hipchat/</link>
        <guid isPermaLink="true">http://datafox.co/hipchat/2014/08/09/hipchat/</guid>
      </item>
    
      <item>
        <title>NodeJs Best Practices: Event Emitting and Async Callbacks</title>
        <description>&lt;h2 id=&quot;the-issue&quot;&gt;The Issue&lt;/h2&gt;

&lt;p&gt;There is a very unfortunate inconsistency at the heart of NodeJS.  As you’ve probably read, everything in Node is non-blocking, which can be extremely efficient without multithreading.  At the same time, JavaScript is built around event emitting, which is a powerful way to decouple code, whether you want to call it Pub/Sub or whatever.&lt;/p&gt;

&lt;p&gt;The issue is that doing…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myObject.emit(&quot;some notification...&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…is a blocking operation while all listeners respond.&lt;/p&gt;

&lt;p&gt;I’ve talked to core contributors that argue this is a fundamental design flaw in Node, and are arguing to change it.  I’ve also read good arguments that the listeners should be blocking, otherwise there is no guarantee they’ll have a chance to respond to the event before it’s too late.  The important point is that you should be aware of this inconsistency and plan accordingly.  Which brings me to my next point:&lt;/p&gt;

&lt;h2 id=&quot;most-nodejs-examples-assume-a-persistent-server&quot;&gt;Most NodeJS Examples Assume a Persistent Server&lt;/h2&gt;

&lt;p&gt;A related problem I have encountered with events is that Node tutorials tend to assume that you are working with a persistent instance, like a web server, so all events and callbacks will have unlimited time to complete.  This assumption falls apart when you start to write background scripts that are intended to run and shutdown, releasing resources like DB connections.&lt;/p&gt;

&lt;p&gt;My issue occurred because I want to emit and listen for events (to keep my code nicely decoupled), while ensuring that any subsequent asynchronous behavior completes.  To make this more concrete:&lt;/p&gt;

&lt;p&gt;When you create a company in &lt;a href=&quot;http://www.datafox.co&quot;&gt;DataFox&lt;/a&gt;, we trigger many background jobs like crawling the corporation’s website and hitting various APIs.  Rather than have my &lt;code&gt;Company&lt;/code&gt; class know about all of these ever-changing jobs, I have it emit a “new company” event, which those jobs can listen for.  So for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// in WebsiteCrawler
Company.on(&#39;new company&#39;, function(company) {
  // the request is non-blocking.
  request.get(company.url, function(err, response) {
    // process the response and write to the db...
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens if my script completes before the http response gets back?  Yes, Node will not terminate running while there are outstanding callbacks, but I can still have issues if I’ve disconnected from the database.&lt;/p&gt;

&lt;h2 id=&quot;my-solution&quot;&gt;My Solution&lt;/h2&gt;

&lt;p&gt;The solution is to avoid doing any real work (asynchronous calls) in an event listener.  For me this means a listener should enqueue the work to be done, using &lt;a href=&quot;https://github.com/caolan/async#queue&quot;&gt;async.queue&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetchUrlQueue = async.queue(functionThatWillFetchUrl);
Company.on(&#39;new company&#39;, function(company) {
  fetchUrlQueue.push({url: company.url});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I can check that this queue is drained before disconnecting from the database, etc. and shutting down my script.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/08/02/nodejs-best-practices-event-emitting-and-async/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/08/02/nodejs-best-practices-event-emitting-and-async/</guid>
      </item>
    
      <item>
        <title>NodeJS Best Practices: Callbacks</title>
        <description>&lt;p&gt;As an experienced programmer, I’ve found that NodeJS is easy to learn with many tutorials to cover the basics.  However, I was (and still am) unclear about what are the best practices for NodeJS. Here are a few of the things I’ve learned so far about callbacks:&lt;/p&gt;

&lt;h2 id=&quot;everything-in-node-should-be-done-with-callbacks&quot;&gt;&lt;em&gt;Everything&lt;/em&gt; in Node should be done with callbacks.&lt;/h2&gt;

&lt;p&gt;It can be tempting to write functions that just return results like:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculateScore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But that’s generally a bad idea because you’ve closely tied your interface to your implementation.  That means if you decide to change your implementation to do something asynchronous, like fetching a cached value, you now have to change all of your callers.  In practice you’ll run into a lot of bugs where the function actually returns nothing (undefined) or fails to call a callback, making your program hang.&lt;/p&gt;

&lt;p&gt;NodeJS requires you to invert the usual sequential way of solving problems into an asynchronous set of callbacks.  Embrace it.  Once you wrap your head around this inverted idea, it’s actually a lot of fun and powerful.  Have you ever tried to run parallel database queries in PHP?&lt;/p&gt;

&lt;h2 id=&quot;use-the-async-library-to-organize-your-callbacks&quot;&gt;Use the async library to organize your callbacks&lt;/h2&gt;

&lt;p&gt;There are some lots of ways to prevent “callback soup,” but here’s what worked for me in practice:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Move most of your anonymous callbacks to clearly named functions, following good object-oriented design.&lt;/li&gt;
  &lt;li&gt;Use the awesome &lt;a href=&quot;https://github.com/caolan/async&quot;&gt;async library&lt;/a&gt; to handle all of your common practices like calling functions in parallel or in a series.  Promises and generators are both cool ideas that falter in practice.  Async just works.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;callbacks-should-have-exactly-two-arguments&quot;&gt;Callbacks should have &lt;strong&gt;exactly two&lt;/strong&gt; arguments&lt;/h2&gt;

&lt;p&gt;What’s wrong with this code?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fs.exists(&#39;/etc/passwd&#39;, function (err, exists) {
  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs.exists&lt;/code&gt; doesn’t follow the convention of invoking a callback with an &lt;code&gt;err&lt;/code&gt; parameter so &lt;code&gt;exists&lt;/code&gt; is undefined and silently cast to false. Oops.&lt;/p&gt;

&lt;p&gt;One of my biggest frustrations is how unpredictable callbacks are in NodeJS, because the number of arguments is arbitrary. While most authors respect the convention that the first argument is an error (or null), you can’t rely on it.  The problem is compounded if you use the async library, which expects the standard (err, data) format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async.waterfall([
  function(next) {
    fs.exists(&#39;/etc/passwd&#39;, next);
  },
  function(next) {
    // next is undefined and the script hangs...
  }
], ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, I believe strongly that you should pass the actual response as one argument.  This is the same reason you should not return multiple values from a function.  For example this is bad practice in Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# changing this array will probably break callers
return [users, total_users]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This happens often enough in Node libraries to be infuriating.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mongoose js model
user.save(function(err, user, num) {
  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The real reason this is a problem is that you are violating the &lt;strong&gt;Single Responsibility Principle&lt;/strong&gt;: your function returns multiple arguments because it’s trying to do more than one thing.  The awkward callback is a symptom of OO design that needs rethinking.  In this case it would really be better to return some type of Response object that encapsulates the saved model, number saved, etc.  In the future you can add information like query time without breaking the contract.&lt;/p&gt;

&lt;p&gt;In practice this ambiguity has caused more bugs for me than anything else.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async.waterfall([
  function(callback) {
    user.save(callback);
  },
  function(user, callback) {
   // oops, next is actually a number, so there is an error or the script just hangs
  },
  ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rigidly sticking with the convention of &lt;code&gt;callback(err, data)&lt;/code&gt; saves a lot of headache.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;NodeJS is awesome, but the best practices are stilling emerging.  I hope these thoughts are helpful to others who are adopting NodeJS and I’d love to hear more about other best practices.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 Jun 2014 05:03:49 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-callbacks/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-callbacks/</guid>
      </item>
    
  </channel>
</rss>
