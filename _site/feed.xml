<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DataFox Tech Blog</title>
    <description>DataFox Tech Blog</description>
    <link>http://datafox.co/</link>
    <atom:link href="http://datafox.co/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Automate Everything Using Hipchat</title>
        <description>&lt;p&gt;We’re huge fans of &lt;a href=&quot;https://www.hipchat.com/&quot;&gt;HipChat&lt;/a&gt; here at DataFox and it has rapidly become our central means of communication.&lt;/p&gt;

&lt;p&gt;We started by using it as a simple instant messenger for 1:1 conversations, and then expanded to using the chat rooms as a way to send out customer feedback without clogging our inboxes.  And it has become the way to broadcast announcements like &lt;code&gt;@all order lunch from [doordash](http://doordash.com)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But that’s just the beginning.  HipChat is also &lt;em&gt;the&lt;/em&gt; simplest way to communicate with our automated tools and processes.  No more e-mails or dashboards spread across 10 different systems.  By consolidating our messaging through HipChat we get all of our alerts in one place and can instantly discuss everything that is happening.&lt;/p&gt;

&lt;h3 id=&quot;deployment-and-configuration&quot;&gt;Deployment and Configuration&lt;/h3&gt;

&lt;h4 id=&quot;continuous-integration&quot;&gt;Continuous Integration&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;Jenkins&lt;/a&gt; has become the standard way to run continuous integration and deployment, and it defaults to e-mailing you when builds or tests fail.  But if you’re like me, you’ve already set up e-mail filters to ignore this noise.&lt;/p&gt;

&lt;p&gt;Fortunately, it takes less than 5 minutes to install and configure the &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/HipChat+Plugin&quot;&gt;HipChat plugin&lt;/a&gt; to broadcast when builds fail.  Now everyone sees a growl notification on failure (configurable, of course) and you can discuss the issue right there with your team.  No more e-mail threads!&lt;/p&gt;

&lt;h4 id=&quot;deployment&quot;&gt;Deployment&lt;/h4&gt;
&lt;p&gt;We use &lt;a href=&quot;http://docs.ansible.com/index.html&quot;&gt;Ansible&lt;/a&gt; for all of our deployment and configuration, and highly recommend it.  Ansible is designed to simple and powerful, with almost no setup.  For example, Ansible comes with a hipchat module that makes it trivial to broadcast when you’ve deployed code to a server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
# ... steps to deploy your code ...

- name: &quot;Broadcast deployment in hipchat&quot;
  hipchat: token= room= msg=&quot; server deployed.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in your &lt;code&gt;vars.yml&lt;/code&gt; file you define these two variables (inventory_hostname is the server name, like “db.datafox.co”)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
hipchat_api_key: ...
hipchat_engineering_room_id: ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows up as an alert like:
(screenshot of deployment notifications, blur out actual server name?)&lt;/p&gt;

&lt;p&gt;Similarly, it’s trivial to broadcast changes in configuration.  Have you ever wasted 4 hours debugging an issue only to learn that someone has had just updated a conf file?  With a few lines in ansible you can create a log of all changes to your production servers.&lt;/p&gt;

&lt;h3 id=&quot;monitoring&quot;&gt;Monitoring&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://mmonit.com/monit/&quot;&gt;Monit&lt;/a&gt; is a very lightweight and powerful tool for monitoring your servers and services.  For example, we can alert if a server is running out of storage, by creating a file at &lt;code&gt;/etc/monit/conf.d/diskspace&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check filesystem rootfs with path /
if space usage &amp;gt; 80% then alert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;similarly, it’s easy to monitor our various backend services and remote connections.  By default monit will send alert e-mails, but it’s far more useful to have the messages sent to hipchat where they can trigger a growl notification and show up in context of any recent deployments or other changes.&lt;/p&gt;

&lt;p&gt;To make this work we just wrote a quick-and-dirty python script to send hipchat messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys, urllib, urllib2, json

values = {
  &#39;room_id&#39;        : 12345,
  &#39;message&#39;        : &#39;message to send&#39;,
  &#39;color&#39;          : &#39;red&#39;,
  &#39;from&#39;           : &#39;server.datafox.co&#39;,
  &#39;notify&#39;         : 0,
  &#39;message_format&#39; : &#39;text&#39;
}

# yes, this should use optparse...
last_command = &#39;&#39;
for i, arg in enumerate(sys.argv):
  if i % 2 == 1:
    last_command = arg
  elif i != 0:
    if last_command == &#39;-m&#39;:
      values[&#39;message&#39;] = arg
    elif last_command == &#39;-f&#39;:
      values[&#39;from&#39;] = arg
    elif last_command == &#39;-r&#39;:
      room_id = arg
    elif last_command == &#39;-c&#39;:
      values[&#39;color&#39;] = arg
    elif last_command == &#39;-n&#39;:
      values[&#39;notify&#39;] = arg
    elif last_command == &#39;-fm&#39;:
      values[&#39;format&#39;] = arg
    else:
      print &#39;Unrecognized argument: &#39; + last_command
      sys.exit()

url = &#39;https://api.hipchat.com/v1/rooms/message?auth_token= ...&#39;
req = urllib2.Request(url, urllib.urlencode(values))
urllib2.urlopen(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then invoke it from monit like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# if service is unavailable 3 times in a row, send an alert that we are restarting
if failed host localhost port 12345 protocol http for 3 cycles then restart
then exec &quot;/var/hipchat/hipchat_cli.py -m &#39;some-server process failed on server.datafox.co -- restarting.&#39; -f &#39;Monit&#39; -n 1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bugs-and-uncaught-exceptions&quot;&gt;Bugs and Uncaught Exceptions&lt;/h3&gt;

&lt;p&gt;We use &lt;a href=&quot;https://bugsnag.com&quot;&gt;Bugsnag&lt;/a&gt; to report uncaught errors in our frontend JavaScript, as well as in our backend NodeJS and Python services.  I haven’t used any of the competing products, but Bugsnag was extremely easy to setup and automatically groups all errors,  so we are alerted the 1st, 10th, 100th, etc. time an error occurs.&lt;/p&gt;

&lt;p&gt;Connecting Bugsnag to HipChat takes less than 60 seconds, and now we can immediately see if the errors started occurring after a deployment.&lt;/p&gt;

&lt;h3 id=&quot;and-more&quot;&gt;And More…&lt;/h3&gt;

&lt;p&gt;With widespread adoption it seems like most cloud-based services support HipChat.  We particularly rely on NewRelic alerts, but also use Github.  The only concern is drowning out the useful signal with noise (e.g. github commits).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hipchat-screenshot.png&quot; style=&quot;width: 100%&quot; /&gt;
&lt;small&gt;&lt;b&gt;Pictured Above:&lt;/b&gt; HipChat showing a git push to our Master branch, followed by an automated Jenkins build and Ansible deployment. Unfortunately, this deployment resulted in a bug which was subsequently caught by bugsnag and displayed prominently in HipChat.&lt;/small&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/hipchat/2014/08/09/hipchat/</link>
        <guid isPermaLink="true">http://datafox.co/hipchat/2014/08/09/hipchat/</guid>
      </item>
    
      <item>
        <title>NodeJs Best Practices: Event Emitting and Async Callbacks</title>
        <description>&lt;h2 id=&quot;the-issue&quot;&gt;The Issue&lt;/h2&gt;

&lt;p&gt;There is a very unfortunate inconsistency at the heart of NodeJS.  As you’ve probably read, everything in Node is non-blocking, which can be extremely efficient without multithreading.  At the same time, JavaScript is built around event emitting, which is a powerful way to decouple code, whether you want to call it Pub/Sub or whatever.&lt;/p&gt;

&lt;p&gt;The issue is that doing…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myObject.emit(&quot;some notification...&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…is a blocking operation while all listeners respond.&lt;/p&gt;

&lt;p&gt;I’ve talked to core contributors that argue this is a fundamental design flaw in Node, and are arguing to change it.  I’ve also read good arguments that the listeners should be blocking, otherwise there is no guarantee they’ll have a chance to respond to the event before it’s too late.  The important point is that you should be aware of this inconsistency and plan accordingly.  Which brings me to my next point:&lt;/p&gt;

&lt;h2 id=&quot;most-nodejs-examples-assume-a-persistent-server&quot;&gt;Most NodeJS Examples Assume a Persistent Server&lt;/h2&gt;

&lt;p&gt;A related problem I have encountered with events is that Node tutorials tend to assume that you are working with a persistent instance, like a web server, so all events and callbacks will have unlimited time to complete.  This assumption falls apart when you start to write background scripts that are intended to run and shutdown, releasing resources like DB connections.&lt;/p&gt;

&lt;p&gt;My issue occurred because I want to emit and listen for events (to keep my code nicely decoupled), while ensuring that any subsequent asynchronous behavior completes.  To make this more concrete:&lt;/p&gt;

&lt;p&gt;When you create a company in &lt;a href=&quot;http://www.datafox.co&quot;&gt;DataFox&lt;/a&gt;, we trigger many background jobs like crawling the corporation’s website and hitting various APIs.  Rather than have my &lt;code&gt;Company&lt;/code&gt; class know about all of these ever-changing jobs, I have it emit a “new company” event, which those jobs can listen for.  So for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// in WebsiteCrawler
Company.on(&#39;new company&#39;, function(company) {
  // the request is non-blocking.
  request.get(company.url, function(err, response) {
    // process the response and write to the db...
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens if my script completes before the http response gets back?  Yes, Node will not terminate running while there are outstanding callbacks, but I can still have issues if I’ve disconnected from the database.&lt;/p&gt;

&lt;h2 id=&quot;my-solution&quot;&gt;My Solution&lt;/h2&gt;

&lt;p&gt;The solution is to avoid doing any real work (asynchronous calls) in an event listener.  For me this means a listener should enqueue the work to be done, using &lt;a href=&quot;https://github.com/caolan/async#queue&quot;&gt;async.queue&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetchUrlQueue = async.queue(functionThatWillFetchUrl);
Company.on(&#39;new company&#39;, function(company) {
  fetchUrlQueue.push({url: company.url});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I can check that this queue is drained before disconnecting from the database, etc. and shutting down my script.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Aug 2014 00:00:00 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/08/02/nodejs-best-practices-event-emitting-and-async/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/08/02/nodejs-best-practices-event-emitting-and-async/</guid>
      </item>
    
      <item>
        <title>NodeJs Best Practices: Streams</title>
        <description>&lt;h2 id=&quot;streams-are-better-in-theory-than-practice&quot;&gt;Streams are better in theory than practice&lt;/h2&gt;

&lt;p&gt;Streams are an elegant and powerful idea in NodeJS, allowing you to process large data sets efficiently without loading them all into memory at once.  You can even pipe streams like unix, to chain together processing.&lt;/p&gt;

&lt;p&gt;The only issue is that while Node v.10 vastly improved streams, the libraries (e.g. MongooseJS and csv-node) have not caught up.  To use a simple example, this is how you should be to process millions of collections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// users is a massive table with millions of documents
stream = Users.find().stream();
stream.on(‘data’, function(user) {
  stream.pause();
  doSomethingExpensive(user, function() {
    stream.resume();
  });
});
stream.on(‘end’, function() {
  // all done, disconnect from the db
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…except the stream.pause() function is “strictly advisory” and therefore doesn’t work :(.  I’ve experienced the same problems in other libraries.&lt;/p&gt;

&lt;p&gt;I hope this is rapidly solved as the libraries mature, because this is a much better way to think about data problems.  However, I will reserve judgment until then.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 Jun 2014 05:03:49 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-streams/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-streams/</guid>
      </item>
    
      <item>
        <title>NodeJs Best Practices: Avoiding Circular Dependencies</title>
        <description>&lt;h2 id=&quot;avoid-circular-requires-in-nodejs&quot;&gt;Avoid Circular Requires in NodeJS&lt;/h2&gt;

&lt;p&gt;I recently ran into this error: “getUser is not defined”.&lt;/p&gt;

&lt;p&gt;My code looked this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserService = require(‘./user’);

module.exports = function CompanyService() {

  this.getCompaniesForUser = function() {
    userService = new UserService;
    userService.getUser(...);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing looks wrong.  After debugging I found that &lt;code&gt;UserService = {}&lt;/code&gt;.  What?&lt;/p&gt;

&lt;p&gt;The issue turns out to be a circular dependency.  If you have two files that require each other like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B = require(&#39;./file_b&#39;);
module.exports = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A = require(&#39;./file_a&#39;);
// A == {}

module.exports = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When B tries to require A, A is not initialized, so you actually import an empty object!  I’m curious if there is a good explanation for this silent failure, but it seems like a serious design flaw to me.&lt;/p&gt;

&lt;p&gt;The solution is to either avoid the circular import if possible, or to lazy-require the files.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getB = function() {
  B = require(&#39;./file_b&#39;);
  return new B;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that NodeJS modules are cached, so it’s okay to call the function repeatedly.)&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Jun 2014 05:03:49 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-circular-dependencies/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-circular-dependencies/</guid>
      </item>
    
      <item>
        <title>NodeJS Best Practices: Callbacks</title>
        <description>&lt;p&gt;As an experienced programmer, I’ve found that NodeJS is easy to learn with many tutorials to cover the basics.  However, I was (and still am) unclear about what are the best practices for NodeJS. Here are a few of the things I’ve learned so far about callbacks:&lt;/p&gt;

&lt;h2 id=&quot;everything-in-node-should-be-done-with-callbacks&quot;&gt;&lt;em&gt;Everything&lt;/em&gt; in Node should be done with callbacks.&lt;/h2&gt;

&lt;p&gt;It can be tempting to write functions that just return results like:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculateScore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But that’s generally a bad idea because you’ve closely tied your interface to your implementation.  That means if you decide to change your implementation to do something asynchronous, like fetching a cached value, you now have to change all of your callers.  In practice you’ll run into a lot of bugs where the function actually returns nothing (undefined) or fails to call a callback, making your program hang.&lt;/p&gt;

&lt;p&gt;NodeJS requires you to invert the usual sequential way of solving problems into an asynchronous set of callbacks.  Embrace it.  Once you wrap your head around this inverted idea, it’s actually a lot of fun and powerful.  Have you ever tried to run parallel database queries in PHP?&lt;/p&gt;

&lt;h2 id=&quot;use-the-async-library-to-organize-your-callbacks&quot;&gt;Use the async library to organize your callbacks&lt;/h2&gt;

&lt;p&gt;There are some lots of ways to prevent “callback soup,” but here’s what worked for me in practice:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Move most of your anonymous callbacks to clearly named functions, following good object-oriented design.&lt;/li&gt;
  &lt;li&gt;Use the awesome &lt;a href=&quot;https://github.com/caolan/async&quot;&gt;async library&lt;/a&gt; to handle all of your common practices like calling functions in parallel or in a series.  Promises and generators are both cool ideas that falter in practice.  Async just works.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;callbacks-should-have-exactly-two-arguments&quot;&gt;Callbacks should have &lt;strong&gt;exactly two&lt;/strong&gt; arguments&lt;/h2&gt;

&lt;p&gt;What’s wrong with this code?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fs.exists(&#39;/etc/passwd&#39;, function (err, exists) {
  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs.exists&lt;/code&gt; doesn’t follow the convention of invoking a callback with an &lt;code&gt;err&lt;/code&gt; parameter so &lt;code&gt;exists&lt;/code&gt; is undefined and silently cast to false. Oops.&lt;/p&gt;

&lt;p&gt;One of my biggest frustrations is how unpredictable callbacks are in NodeJS, because the number of arguments is arbitrary. While most authors respect the convention that the first argument is an error (or null), you can’t rely on it.  The problem is compounded if you use the async library, which expects the standard (err, data) format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async.waterfall([
  function(next) {
    fs.exists(&#39;/etc/passwd&#39;, next);
  },
  function(next) {
    // next is undefined and the script hangs...
  }
], ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, I believe strongly that you should pass the actual response as one argument.  This is the same reason you should not return multiple values from a function.  For example this is bad practice in Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# changing this array will probably break callers
return [users, total_users]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This happens often enough in Node libraries to be infuriating.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mongoose js model
user.save(function(err, user, num) {
  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The real reason this is a problem is that you are violating the &lt;strong&gt;Single Responsibility Principle&lt;/strong&gt;: your function returns multiple arguments because it’s trying to do more than one thing.  The awkward callback is a symptom of OO design that needs rethinking.  In this case it would really be better to return some type of Response object that encapsulates the saved model, number saved, etc.  In the future you can add information like query time without breaking the contract.&lt;/p&gt;

&lt;p&gt;In practice this ambiguity has caused more bugs for me than anything else.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async.waterfall([
  function(callback) {
    user.save(callback);
  },
  function(user, callback) {
   // oops, next is actually a number, so there is an error or the script just hangs
  },
  ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rigidly sticking with the convention of &lt;code&gt;callback(err, data)&lt;/code&gt; saves a lot of headache.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;NodeJS is awesome, but the best practices are stilling emerging.  I hope these thoughts are helpful to others who are adopting NodeJS and I’d love to hear more about other best practices.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 Jun 2014 05:03:49 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-callbacks/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-callbacks/</guid>
      </item>
    
      <item>
        <title>NodeJs Best Practices: Avoid Optional Parameters</title>
        <description>&lt;p&gt;NodeJS authors really love taking advantage of JavaScript’s looseness to create ambiguous functions.  For example, mongoose (MongoDB ORM)’s &lt;code&gt;populate&lt;/code&gt; function can be invoked any of these ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.populate(&#39;path&#39;)

.populate(&#39;path1 path2&#39;)

.populate(&#39;path1&#39;).populate(&#39;path2&#39;)

.populate({path: &#39;path&#39;, ...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with subtly varying results.&lt;/p&gt;

&lt;p&gt;I also frequently see code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myFunction(api, options, callback) {
  if (typeof callback === &quot;undefined&quot;)
    callback = options
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feels very clever, but really it just achieves the convenience of being able to write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myFunction(‘my/api/endpoint/‘, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myFunction(‘my/api/endpoint/‘, {}, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m not sure why these patterns are so common, but I suspect the author believes they are supporting a wider variety of inputs and shorthands.  In practice this has makes code:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;harder to document and search&lt;/li&gt;
  &lt;li&gt;harder to predict, since it may accept more than you expect&lt;/li&gt;
  &lt;li&gt;harder to catch mistakes, since the code will tries to accomodate those unintended mistakes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Experience has taught me the importance of writing explicit code.  Ambiguity causes bugs.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Jun 2014 05:03:49 -0700</pubDate>
        <link>http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-avoid-optional-parameters/</link>
        <guid isPermaLink="true">http://datafox.co/nodejs/2014/06/08/nodejs-best-practices-avoid-optional-parameters/</guid>
      </item>
    
  </channel>
</rss>
